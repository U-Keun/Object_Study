>모든 소프트웨어 모듈에는 세 가지 목적이 있다. 첫 번째 목적은 실행 중에 제대로 동작하는 것이다. 이것은 모듈의 존재 이유라고 할 수 있다.
>두 번째 목적은 변경을 위해 존재하는 것이다. 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다. 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 한다.
>모듈의 세 번째 목적은 코드를 읽는 사람과 의사소통하는 것이다. 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다. 읽는 사람과 의사소통할 수 없는 모듈은 개선해야 한다.
> -- <클린 소프트웨어: 애자일 원칙과 패턴, 그리고 실천 방법>, 로버트 마틴(Robert C. Martin)

#### 초기 `Theater` 클래스의 `enter()` 메서드가 수행하는 일
>소극장은 관람객의 가방을 열어 그 안에 초대장이 들어 있는지 살펴본다.
가방 안에 초대장이 들어 있으면 판매원은 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다.
가방 안에 초대장이 들어 있지 않다면 관람객의 가방에서 티켓 
금액만큼의 현금을 꺼내 매표소에 적립한 후에 매표소에 보관돼 있는 관람객의 가방 안으로 옮긴다.

- 관람객(`Audience` 객체)와 판매원(`TicketSeller` 객체)이 소극장(`Theater` 객체)의 통제를 받는 수동적인 존재이다.
  -> 사람의 입장에서 행동의 흐름이 어색하다 -> 코드를 읽는 사람과 의사소통이 잘 되지 않는다..?
  - 관람객의 입장에서 소극장이라는 제3자가 초대장을 확인하기 위해 관람객의 가방을 열어본다.
  - 판매원의 입장에서 소극장이라는 제3자가 매표소에 보관 중인 티켓과 현금에 마음대로 접근할 수 있다.
- 이 코드를 이해하기 위해서는 여러 가지 세부적인 내용들을 한꺼번에 기억하고 있어야 한다.
  - `Theater`의 `enter` 메서드를 이해하기 위해서는 `Audience`가 `Bag`을 가지고 있고, `Bag` 안에는 현금과 티켓이 들어있으며, `TicketSeller`가 `TicketOffice`에서 티켓을 판매하고, `TicketOffice` 안에 돈과 티켓이 보관돼 있다는 사실을 알고 있어야 한다.
- `Audience`와 `TicketSeller`를 변경할 경우 `Theater`도 함께 변경해야 한다.
  - `Audience`가 `Bag`을 갖고 있다는 가정이 바뀐다면 ->
    - `Audience`에서 `Bag`을 제거
    - `Audience`의 `Bag`에 직접 접근하는 `Theater`의 `enter` 메서드 수정
    - ...
### 객체 사이의 의존성(dependency)
- `A`라는 클래스가 `B`라는 클래스의 내부에 대해 더 많이 알면 알수록 변경하기가 어렵다.
  - '내부에 대해 더 많이 안다' = '어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다' = '결합도가 높다'

***애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거해야 한다.***

- 불필요한 의존성
  - `Theater`의 입장에서 관람객이 가방을 가지고 있다는 사실과 판매원이 매표소에서 티켓을 판매한다는 사실은 알 필요가 없다.

### 객체를 더 자율적인 존재로..!
- 수정할 부분
  - 관람객은 스스로 가방 안의 현금과 초대장을 처리할 수 있다. -> `Audience`가 직접 `Bag`을 관리하도록
    - `TicketSeller`는 `Audience`가 `buy` 메시지를 이해하고 응답할 수 있다는 사실만 알고 있게 된다.
  - 판매원은 스스로 매표소의 티켓과 판매 요금을 다룰 수 있다. -> `TicketSeller`가 직접 `TicketOffice`를 관리하도록
    - `Theater`는 `ticketSeller`가 `sellTo` 메시지를 이해하고 응답할 수 있다는 사실만 알고 있게 된다.

`TicketSeller`는 오직 `Audience`의 인터페이스(`buy` 메서드)에만 의존한다. `Audience`가 내부에 `Bag` 인스턴스를 포함하고 있다는 사실은 구현의 영역이다.

`Theater`는 오직 `TicketSeller`의 인터페이스(`sellTo` 메서드)에만 의존한다. `TicketSeller`가 내부에 `TicketOffice` 인스턴스를 포함하고 있다는 사실은 구현의 영역이다.

객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위한 설계 원칙이다.

> 캡슐화 : 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것. 변경하기 쉬운 객체를 만들기 위해 사용된다. 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문이다.

- *응집도* 가 높은 객체 : 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체
  - 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.
  - 객체 스스로 자신의 데이터를 책임져야 한다.

객체의 자율성을 높이는 과정에서, 기존에는 없던 의존성이 추가되는 경우도 있다. 이런 경우에는 어떤 것을 우선해야 하는지를 비교해서, 더 중요한 것을 챙길 수 있도록 설계해야 한다.

### 책임 == 기능
책임(기능)이 집중돼 있을수록, 그 객체는 필요한 모든 객체에 의존해야하고, 그 결과로 변경에 취약해진다. 각 객체에 책임(기능)을 적절하게 분배해서, 각 객체가 자신을 스스로 책임지도록 설계해야
변경에 잘 대응할 수 있다.

-------------------------------
- '클래스 `A`가 클래스 `B`의 내부에 대해 많이 안다'라는 것은 클래스 `A`가 내부적으로 `B` 타입 객체를 생성하거나, `B` 클래스의 메서드를 사용한다는 것으로 정의하는 것이 충분할까? 